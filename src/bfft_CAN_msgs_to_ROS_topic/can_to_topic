#!/usr/bin/env python3
# coding: utf-8

import rospy
from std_msgs.msg import String
from sensor_msgs.msg import NavSatFix, NavSatStatus, Imu
from can_msgs.msg import Frame
from geometry_msgs.msg import Quaternion, Vector3

from bfft_CAN_msgs_to_ROS_topic.msg import Can_id_msg

import transforms3d
import time

import pandas as pd
import cantools

## ModuleNotFoundError: No module namend GPS class - TBD
from utilities_IMU.gps_class import GPSClass
from utilities_IMU.imu_class import IMUClass
from utilities_IMU.utility_classes import StatusErrorClass, UnknownCANIdsClass

def decode_CAN_data():
    """Receive all CAN Data from ROS Channel received_messages, decode it using the DBC Files defined
    in the Launch file and stream it to the relating topics"""
    
    gps_data = GPSClass()
    imu_data = IMUClass()
    unknown_can_id_data = UnknownCANIdsClass()
    
    pub_gps = rospy.Publisher('imu/gps_data', NavSatFix, queue_size=10)
    pub_imu = rospy.Publisher('imu/imu_data', Imu, queue_size=10)
    pub_unknown_ids = rospy.Publisher('can/unknown_ids', Can_id_msg, queue_size=10) 
    
    # get parameters from launch file
    path_to_adma_dbc_file = rospy.get_param('/can_to_topic/path_to_adma_dbc_file')
    path_to_sensor_dbc_file = rospy.get_param('/can_to_topic/path_to_sensor_dbc_file')

    dbc_adma_file = open(path_to_adma_dbc_file, "r", encoding="iso-8859-1")
    db_adma = cantools.database.load(dbc_adma_file)
    
    dbc_sensor_file = open(path_to_sensor_dbc_file, "r", encoding="iso-8859-1")
    db_sensor = cantools.database.load(dbc_sensor_file)
    
    base_id_adma = int(rospy.get_param('/can_to_topic/base_id_adma'))
    
    def convert_msgs(can_id, header, decoded_msgs):
        msgs = pd.DataFrame.from_dict([decoded_msgs])
        
        secs = header.stamp.secs
        nsecs = header.stamp.nsecs
        
        can_identifier = str(can_id)
        
        def __status_bits():
            print("Status Bits identifier: "+can_identifier)
            '''
            'Stat_Byte0_GPS_Mode'
            'Stat_Byte0_Standstill'
            'Stat_Byte0_Skidding'
            'Stat_Byte0_External_Vel_Out'
            'Stat_Byte1_Trig_GPS'
            'Stat_Byte1_Signal_IN3'
            'Stat_Byte1_Signal_IN2'
            'Stat_Byte1_Signal_IN1'
            'Stat_Byte1_Alignment'
            'Stat_Byte1_AHRS_INS'
            'Stat_Byte1_Deadreckoning'
            'Stat_Byte1_SyncLock'
            'Stat_Byte2_EVK_activ'
            'Stat_Byte2_EVK_Estimates'
            'Stat_Byte2_Tilt'
            'Stat_Byte2_Pos'
            '''
        def __error_bits():
            print("Error and Warning Bits identifier: "+can_identifier)
            '''
            'Errors_Byte0_HW'
            'Errors_Byte0_Nibble1'
            'Errors_Byte1_Nibble0'
            'Errors_Byte1_Nibble1'
            'Warn_Byte2_GPS'
            '''
            
        def __rates_body():
            x = msgs.loc[0, "RXB"]
            y = msgs.loc[0, "RYB"]
            z = msgs.loc[0, "RZB"]
            imu_data.set_angular_velocity(x,y,z)
                        
        def __acc_body():
            x = msgs.loc[0, "AXB"]
            y = msgs.loc[0, "AYB"]
            z = msgs.loc[0, "AZB"]
            imu_data.set_linear_acceleration(x,y,z)
        
        def __euler_to_quaternions():
            #print(can_identifier+" Euler data = ")
            roll = msgs.loc[0, "Angle_Roll"]
            pitch = msgs.loc[0, "Angle_Pitch"]
            yaw = msgs.loc[0, "Angle_Yaw"]

            ## tf not available with python3 and ros melodic so using transforms3d library
            quat_tf = transforms3d.taitbryan.euler2quat(yaw, pitch, roll)
            imu_data.set_quaternions(quat_tf[0], quat_tf[1], quat_tf[2], quat_tf[3])

        def __altitude():
            #global gps_data
            altitude = msgs.loc[0, "In_Height"]
            gps_data.set_altitude(altitude)

        def __ins_time_utc():
            '''Realtime not used right now, timestamp ROS is already added in GPS_absolut. TBD'''
            millisec = msgs.loc[0, "INS_Time_Millisec"]
            time.secs = (millisec/1000) % 60
            time.nsecs = 0                                     # TBD

        def __gps_absolut():
            lat = msgs.loc[0, "In_Lat"]
            longi = msgs.loc[0, "In_Long"]
            
            print(longi)
            gps_data.set_lat_long(latitude=lat, longitude=longi) 
            gps_data.set_time(secs=secs, nsecs=nsecs)
        
        def __analogin():
            print(can_identifier+" Analog Input data = ", msgs)
            print(msgs.loc[:,:])
            
        def __ins_expected_volocity_tilt_error():
            print(can_identifier+" INS Expected Velocity Error and Tilt Error = ", msgs)
            print(msgs.loc[:,:])            

        def __default():
            ''' If user enters invalid option then this method will be called '''
            #print("Unkonwn ID "+can_identifier)
            #print(msgs)
            
            unknown_can_id_data.set_types_values(can_id=can_id, can_msgs=msgs, header=header)

        def __get_id(can_id):
            switcher = {
                base_id_adma+1: __status_bits,
                base_id_adma+2: __error_bits,
                base_id_adma+6: __rates_body,
                base_id_adma+8: __acc_body,
                base_id_adma+49: __euler_to_quaternions,
                base_id_adma+51: __altitude,
                base_id_adma+56: __ins_time_utc,
                base_id_adma+57: __gps_absolut,
                base_id_adma+83: __ins_expected_volocity_tilt_error,
                base_id_adma+84: __analogin
            }
            func = switcher.get(can_id, __default)
            return func()

        __get_id(can_id)

    def callback(Frame):
        
        if Frame.id < base_id_adma or Frame.id > base_id_adma+84:
            output = db_sensors.decode_message(Frame.id, Frame.data)
            print("Please insert ID in DBC Sensor file")
        else:
            output = db_adma.decode_message(Frame.id, Frame.data)

        if output is not None:
            convert_msgs(can_id=Frame.id, header=Frame.header, decoded_msgs=output)

        # publish saved data from gps and imu objects to topics
        pub_gps.publish(gps_data.publish_gps_data())
        pub_imu.publish(imu_data.publish_imu_data())
        #print(unknown_can_id_data.publish_types_values())
        pub_unknown_ids.publish(unknown_can_id_data.publish_types_values())

    rospy.init_node('adma_CAN_msg_translator', anonymous=True)
    rospy.Subscriber("received_messages", Frame, callback, queue_size=10)
    rospy.spin()

if __name__ == '__main__':
    try:
        decode_CAN_data()

    except rospy.ROSInterruptException:
        pass
